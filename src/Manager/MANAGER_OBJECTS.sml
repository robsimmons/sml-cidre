
signature MANAGER_OBJECTS =
  sig
    type modcode and target and linkinfo and StringTree

    type prjid = string

    structure TyName : TYNAME

    structure SystemTools :
      sig
	val delete_file : string -> unit
      end

    structure ModCode :
      sig
	val empty : modcode
	val seq : modcode * modcode -> modcode
	val mk_modcode : target * linkinfo * string -> modcode   (* Use emit or mk_exe to actually emit code.
								  * The string is a unit name. *)
	val exist : modcode -> bool
	val emit : prjid * modcode -> modcode       
	val mk_exe : prjid * modcode * string list * string -> unit  (* produces executable `string' in target directory *)
      end                                                            (* the string list is a list of external object files
								      * as generated by a foreign compiler (e.g., gcc). *)
    type filename = string
    type funstamp and funid
    structure FunStamp :
      sig
	val new : funid -> funstamp
	val from_filemodtime : filename -> funstamp option
	val modTime : funstamp -> Time.time option
	val eq : funstamp * funstamp -> bool
      end

    val funid_from_filename : filename -> funid
    val funid_to_filename : funid -> filename

    type IntFunEnv and IntBasis and ElabEnv and strexp and strid

    structure IntFunEnv :
      sig
	val empty : IntFunEnv
	val initial : IntFunEnv
	val plus : IntFunEnv * IntFunEnv -> IntFunEnv
	val add : funid * (prjid * funstamp * strid * ElabEnv * (unit -> strexp) * IntBasis) * IntFunEnv -> IntFunEnv
	val lookup : IntFunEnv -> funid -> prjid * funstamp * strid * ElabEnv * (unit -> strexp) * IntBasis  
	val restrict : IntFunEnv * funid list -> IntFunEnv
	val enrich : IntFunEnv * IntFunEnv -> bool  (* using funstamps *)
	val layout : IntFunEnv -> StringTree
      end

    type IntSigEnv and sigid
    structure IntSigEnv :
      sig
	val empty : IntSigEnv
	val initial : IntSigEnv
	val plus : IntSigEnv * IntSigEnv -> IntSigEnv
	val add : sigid * TyName.Set.Set * IntSigEnv -> IntSigEnv      (* tynames that occurs free in a signature *)
	val lookup : IntSigEnv -> sigid -> TyName.Set.Set              (* dies on failure *)
	val restrict : IntSigEnv * sigid list -> IntSigEnv
	val enrich : IntSigEnv * IntSigEnv -> bool
	val layout : IntSigEnv -> StringTree
      end

    type CEnv and CompileBasis and longtycon and longid and longstrid
    structure IntBasis :
      sig
	val mk : IntFunEnv * IntSigEnv * CEnv * CompileBasis -> IntBasis
	val un : IntBasis -> IntFunEnv * IntSigEnv * CEnv * CompileBasis
	val empty : IntBasis
	val plus : IntBasis * IntBasis -> IntBasis
	val match : IntBasis * IntBasis -> IntBasis
	val agree : longstrid list * IntBasis * IntBasis -> bool   (* structure agreement *)
	val layout : IntBasis -> StringTree

	val enrich : IntBasis * IntBasis -> bool

	val initial : IntBasis
	val restrict : IntBasis * {funids:funid list, sigids:sigid list, longstrids: longstrid list,
				   longvids: longid list, longtycons: longtycon list} -> IntBasis
      end

    type Basis and InfixBasis and ElabBasis and opaq_env
    structure Basis :
      sig
	val empty : Basis
	val mk : InfixBasis * ElabBasis * opaq_env * IntBasis -> Basis
	val un : Basis -> InfixBasis * ElabBasis * opaq_env * IntBasis
	val plus : Basis * Basis -> Basis
	val layout : Basis -> StringTree

	val agree : longstrid list * Basis * (Basis * TyName.Set.Set) -> bool
	val enrich : Basis * (Basis * TyName.Set.Set) -> bool

	val initial : Basis
      end

    type name
    structure Repository :
      sig

	(* Repositories map pairs of a project identifier and a
           functor identifier to a repository object. Thus, a functor
           identifier (and hence source file names) can only be
           declared once in each project. However, different functors
           with the same functor identifier may co-exist in different
           projects (similarly, for source file names). *)

	val clear : unit -> unit
	val delete_entries : prjid * funid -> unit

	  (* Repository lookup's return the first entry for a (prjid,funid)
	   * that is reusable (i.e. where all export (ty-)names are
	   * marked generative.) In particular, entries that have been added, 
	   * cannot be returned by a lookup, prior to executing `recover().' 
	   * The integer provided by the lookup functions can be given to the
	   * overwrite functions for owerwriting a particular
	   * entry. *)

	  (* The elaboration environment in the interpretation
	   * repository is supposed to be the elaboration result of
	   * the functor application/ unit; the environment is necessary 
	   * for checking if reuse is allowed. *)

	type elab_entry = InfixBasis * ElabBasis * longstrid list * (opaq_env * TyName.Set.Set) * 
	  name list * InfixBasis * ElabBasis * opaq_env

	type int_entry = funstamp * ElabEnv * IntBasis * longstrid list * name list * 
	  modcode * IntBasis

	type int_entry' = funstamp * ElabEnv * IntBasis * longstrid list * name list * 
	  modcode * IntBasis
	  
	val lookup_elab : (prjid * funid) -> (int * elab_entry) option
	val lookup_int : (prjid * funid) -> (int * int_entry) option    (* IntModules *) 
	val lookup_int' : (prjid * funid) -> (int * int_entry') option  (* Manager *) 
	  
	val add_elab : (prjid * funid) * elab_entry -> unit
	val add_int : (prjid * funid) * int_entry -> unit          (* IntModules *) 
	val add_int' : (prjid * funid) * int_entry' -> unit        (* Manager *)

	val owr_elab : (prjid * funid) * int * elab_entry -> unit
	val owr_int : (prjid * funid) * int * int_entry -> unit    (* IntModules *)

	val emitted_files : unit -> string list   (* returns the emitted files mentioned in the repository; *)
                                                  (* used for deleting files which are no longer mentioned. *)
	val recover : unit -> unit

          (* Before building a project the repository should be
	   * ``recovered'' meaning that all export names are marked
	   * generative (see NAME). Then, when an entry is reused,
	   * export names are marked non-generative; for an entry to
	   * be reused, all export names must be marked generative. *)

      end
    
  end